%% CLEAN
clear all
clc
fclose('all');
%% clean old build
for p = ["lib", "build", "bin"]
    if exist(pwd+"\"+p,'dir') == 7
        rmdir(pwd+"\"+p);
    end
end
builddir = pwd+"/build/";
%mkdir(builddir);
%% CMAKE
system("cmake --clean-first CmakeLists.txt -S . -B "+builddir);
system("msbuild "+builddir+"/customGoals.sln /p:configuration=RelWithDebInfo");
%% construct extendProblem.cpp
delete('extend.cpp');
fid= fopen('extend.cpp','w');
header = [...
    "#include <Simbody.h>"...
    "#include <OpenSim/OpenSim.h>"...
    "#include <OpenSim/Moco/osimMoco.h>"...
    "#include <OpenSim/Common/TimeSeriesTable.h>"...
    "#include 'mexplus.h'"...
    "#include <vector>"...
    "#include <string>"...
    ];
files = dir(pwd+"/custom_goals");
dirFlags = [files.isdir];
% Extract only those that are directories.
goals = files(dirFlags);
for line = header
    fprintf(fid,'%s\n',line);
end
for goal = {goals.name}
    switch(goal{1})
        case {'.','..'}
            disp('skipping irrelevant dir.')
        otherwise
            line = "#include '" +goal{1}+ ".h'";
            fprintf(fid,'%s\n',line);
    end
end
%% CLASS DEF START
class_def_start = [...
"using namespace std;",...
"using namespace mexplus;",...
"using namespace OpenSim;",...
"using namespace SimTK;",...
"",...
"",...
"class extendProblem",...
"{",...
"public:",...
"    extendProblem(const __int64 p){",...
"        m_p = (OpenSim::MocoProblem *) p;",...
"        mexPrintf(""hello MocoProblem!\n"");",...
"    }",...
"    ~extendProblem(){",...
"        mexPrintf(""goodbye MocoProblem!\n"");",...
"    }",...
];
for line = class_def_start
    fprintf(fid,'%s\n',line);
end
%% create custom goal addition functions
for goal = {goals.name}
    switch(goal{1})
        case {'.','..'}
            disp('skipping irrelevant dir.')
        otherwise
            libPath = pwd+"/custom_goals/"+goal{1}+"/"+goal{1}+".h";
            libPath_data = importdata(libPath);
            ids = intersect(...
                find(contains(libPath_data, 'void')),...
                find(contains(libPath_data, 'set'))...
                );
            args = struct();
            goalfun = "    void add"+ goal{1} +"(const string& goalName, double weight";
            fs = [];
            for i = 1:length(ids)
                [match, nomatch] = regexp(libPath_data{ids(i)},'\(([^)]+)\)','match','split');
                fun = strrep(strrep(nomatch{1},'void',''),' ','');
                arg = match{1};
                arg = split(strrep(strrep(strrep(arg,')',''),'(',''),'const',''),' ');
                arg = arg(~cellfun(@isempty, arg));
                goalfun = goalfun + ", " +arg{1} + " "+ arg{2};
                fs(i) = "        goal->"+fun+"("+arg{2}+");";
            end
            goalfun = goalfun + "){";
            fprintf(fid,'%s\n',goalfun);
            fprintf(fid,'%s\n',"        mexPrintf(""Adding "+goal{1}+" goal\n"");");
            fprintf(fid,'%s\n',"        auto* goal = m_p->addGoal<"+goal{1}+">(goalName, weight);");
            for i = 1:length(ids)
                [match, nomatch] = regexp(libPath_data{ids(i)},'\(([^)]+)\)','match','split');
                fun = strrep(strrep(nomatch{1},'void',''),' ','');
                arg = match{1};
                arg = split(strrep(strrep(strrep(arg,')',''),'(',''),'const',''),' ');
                arg = arg(~cellfun(@isempty, arg));
                goalfun = goalfun + ", " +arg{1} + " "+ arg{2};
                fprintf(fid,'%s\n',"        goal->"+fun+"("+arg{2}+");");
            end          
            fprintf(fid,'%s\n',"    }");
    end
end

%% CLASS DEF END
class_def_end = [...
"private:",...
"    OpenSim::MocoProblem *m_p = NULL;",...
"};",...
];
for line = class_def_end
    fprintf(fid,'%s\n',line);
end
%% MEX DEF START
mex_def_start = [...
"",...
"",...
"",...
"template class mexplus::Session<extendProblem>;",...
"",...
"namespace",...
"{",...
"    MEX_DEFINE(new) (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])",...
"    {",...
"        InputArguments input(nrhs, prhs, 1);",...
"        OutputArguments output(nlhs, plhs, 1);",...
"        output.set(0, Session<extendProblem>::create(new extendProblem(input.get<__int64>(0))));",...
"    }",...
"    MEX_DEFINE(delete) (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])",...
"    {",...
"        InputArguments input(nrhs, prhs, 1);",...
"        OutputArguments output(nlhs, plhs, 0);",...
"        Session<extendProblem>::destroy(input.get(0));",...
"    }",...
];
for line = mex_def_start
    fprintf(fid,'%s\n',line);
end
%% create mex functions
for goal = {goals.name}
    switch(goal{1})
        case {'.','..'}
            disp('skipping irrelevant dir.')
        otherwise
            libPath = pwd+"/custom_goals/"+goal{1}+"/"+goal{1}+".h";
            libPath_data = importdata(libPath);
            ids = intersect(...
                find(contains(libPath_data, 'void')),...
                find(contains(libPath_data, 'set'))...
                );
            args = struct();
            goalfun = "    void add"+ goal{1} +"(const string& goalName, double weight";
            fs = [];
            mex_add_def = ...
            "    MEX_DEFINE(add"+goal{1}+") (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])"+newline+...
            "    {"+newline+...
            "        InputArguments input(nrhs, prhs, "+num2str(length(ids)+3)+");"+newline+...
            "        OutputArguments output(nlhs, plhs, 0);"+newline+...
            "        extendProblem* engine = Session<extendProblem>::get(input.get(0));"+newline+...
            "        engine->addMarkerGoal(input.get<string>(1),input.get<double>(2),";
            for i = 1:length(ids)
                [match, nomatch] = regexp(libPath_data{ids(i)},'\(([^)]+)\)','match','split');
                fun = strrep(strrep(nomatch{1},'void',''),' ','');
                arg = match{1};
                arg = split(strrep(strrep(strrep(arg,')',''),'(',''),'const',''),' ');
                arg = arg(~cellfun(@isempty, arg));
                goalfun = goalfun + ", " +arg{1} + " "+ arg{2};
                mex_add_def = mex_add_def + "input.get<"+arg{1}+">("+num2str(i+2)+"),";
            end
            mex_add_def = mex_add_def + ");"+newline+"    }";
            fprintf(fid,'%s\n',mex_add_def);
    end
end
%% MEX DEF END
mex_def_end =[...
"",...
"} //namespace",...
"",...
"MEX_DISPATCH",...
];
for line = mex_def_end
    fprintf(fid,'%s\n',line);
end
fclose(fid);

%% MAT START
fid= fopen('extend.m','w');

mat_def_start = ...
"classdef extend_problem < handle" + newline + ...
"    " + newline + ...
"    properties (Access = private)" + newline + ...
"        id_ % ID of the session" + newline + ...
"    end" + newline + ...
"    " + newline + ...
"    methods" + newline + ...
"        function this = extend_problem(Cptr)" + newline + ...
"            %extendProblem Create a new" + newline + ...
"            disp(Cptr)" + newline + ...
"            assert(isinteger(Cptr));" + newline + ...
"            this.id_ = extendProblem('new',Cptr);" + newline + ...
"        end" + newline + ...
"        " + newline + ...
"        function delete(this)" + newline + ...
"            %delete Destructor" + newline + ...
"            extendProblem('delete', this.id_);" + newline + ...
"        end";
fprintf(fid,'%s\n',mat_def_start);
%% MAT wrapper functions def
for goal = {goals.name}
    switch(goal{1})
        case {'.','..'}
            disp('skipping irrelevant dir.')
        otherwise
            libPath = pwd+"/custom_goals/"+goal{1}+"/"+goal{1}+".h";
            libPath_data = importdata(libPath);
            ids = intersect(...
                find(contains(libPath_data, 'void')),...
                find(contains(libPath_data, 'set'))...
                );
            f_wrap = "        function add"+goal{1}+"(this,goalname,weight";
            wrapfun = "            extendProblem('add"+goal{1}+"', this.id_,goalname,weight";
            for i = 1:length(ids)
                [match, nomatch] = regexp(libPath_data{ids(i)},'\(([^)]+)\)','match','split');
                fun = strrep(strrep(nomatch{1},'void',''),' ','');
                arg = match{1};
                arg = split(strrep(strrep(strrep(arg,')',''),'(',''),'const',''),' ');
                arg = arg(~cellfun(@isempty, arg));
                f_wrap =f_wrap + ", "+arg{2};
                wrapfun = wrapfun + ", "+arg{2};
            end
            f_wrap = f_wrap + ")";
            wrapfun = wrapfun + ");";
            fprintf(fid,'%s\n',f_wrap);
            fprintf(fid,'%s\n',wrapfun);
            fprintf(fid,'%s\n',"        end");
    end
end
%% MAT END
mat_def_end = ...
"    end" + newline + ...
"end";
fprintf(fid,'%s\n',mat_def_end);